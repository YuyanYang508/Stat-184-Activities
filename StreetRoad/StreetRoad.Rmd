---
title: 'Activity: Street or Road'
author: "Yuyan Yang"
date: "4/1/2022"
output:
  html_document:
    df_print: paged
---

# Part 1: Preprocessing

### Loading libraries

```{r message = FALSE, warning = FALSE}
library(dcData)
library(mosaic)
library(knitr)
library(tidyverse)
library(ggplot2)
```

### Reading in Data

```{r message = FALSE, warning = FALSE}
# 15000 street addresses of registered voters in Wake County, North Carolina
Addresses <- read.csv("https://mdbeckman.github.io/dcSupplement/data/street-addresses.csv", header = T)

# 900,000 street addresses of Medicare Service Providers
download.file(url="https://mdbeckman.github.io/dcSupplement/data/CMS_ProvidersSimple.rds", destfile = "CMS_ProvidersSimple.rds")
AddressesMPS <- readRDS("CMS_ProvidersSimple.rds")
```

### Combine two datasets

```{r message = FALSE, warning = FALSE}
# filter AddressesMPS with only address
AddressesMPS <- AddressesMPS %>%
  select(address)

# row bind two files
Combine <- rbind(Addresses, AddressesMPS)
```

# Part 2: Steps to find road-related words

### Step 1: Describe a pattern

For address, I think it will start with some numbers. Then, there will be a space. After space, it will have characters (name of street). After another space, there are the related words we are looking for(streets, lanes, avenues, etc). 

### Step 2: Translate step 1 to regular expression

```{r message = FALSE, warning = FALSE}
# start with 1 or more digits(street number) + 1 or more space + 1 or more alphabetic character(street name) + 1 or more space + 1 or more alphabetic characters(road-related words)
pattern <- "^\\d+\\s+[A-z]+\\s+[A-z]+"
```

### Step 3: Filter to retain the cases that match the expression

```{r message = FALSE, warning = FALSE}
# filter to retain the cases that match the regular expression, get rid of non-address (like PO box etc.)
Matches <- Combine %>%
  filter(grepl(pattern,address))
```

### Step 4: Retain the cases that do not match the expression

```{r message = FALSE, warning = FALSE}
# filter to retain the cases that do not match the expression (like PO box etc.)
Dont <- Combine %>%
  filter(!grepl(pattern,address))
```

### Step 5: Examine step 3 and step 4 to identidy shortcomings
```{r message = FALSE, warning = FALSE}
# examine matches
head(Matches) 
tail(Matches) # no obvious issue
```

```{r message = FALSE, warning = FALSE}
# examine not match
head(Dont) 
tail(Dont) # issue: some address with non-traditional format were excluded
```

### Step 6: Improved or extend pattern

```{r message = FALSE, warning = FALSE}
# start with 1 or more digits(street number) + 1 or more space + 1 or more alphabetic character(street name) + 1 or more space + 1 or more alphabetic characters(road-related words)
# change 1 or more alphabetic character(street name) to '\\w' to include street name which has numbers (like 7th ave, etc.)
pattern <- "^\\d+\\s+\\w+\\s+[A-z]+"

# filter to retain the cases that match the regular expression, get rid of non-address (like PO box etc.)
Matches <- Combine %>%
  filter(grepl(pattern,address))

# filter to retain the cases that do not match the expression (like PO box etc.)
Dont <- Combine %>%
  filter(!grepl(pattern,address))
```

```{r message = FALSE, warning = FALSE}
# examine matches
head(Matches) 
tail(Matches) # no obvious issue 
```

```{r message = FALSE, warning = FALSE}
# examine not match
head(Dont) 
tail(Dont) # some weird format address were still excluded, but it's hard to extend this time because it will make matches data inaccurate if we further expand regular expression
```

### Step 7: Repeated step 1 ad 6

Repeat process in step 6.

### Step 8: Put extaction parenthesis around the parts of regular expression that contain the information we wat
```{r message = FALSE, warning = FALSE}
# adding parenthesis around last 1 or more alphabetic characters because they are the road-related words
extraction <- "^\\d+\\s+\\w+\\s+([A-z]+)"

# using extract() function to extract the road-related words
street <- Matches %>%
  tidyr::extract(address, into = "road", regex = extraction)
```

# Part 3: Providing a Table in descending order of popularity for the street name identifiers

```{r message = FALSE, warning = FALSE}
# create a data frame called popularity to store the number of the times a street name identifiers shows up in the original data sets (in descending order)
# only store the top 20 street name identifiers
popularity <- street %>% 
  group_by(road) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  top_n(20)

popularity
```

# Part 4: Use ggplot to contrusct a bar chart in descedning order of popularity

```{r message = FALSE, warning = FALSE}
# bar chart in descending order of popularity
popularity %>%
  ggplot(aes(x=reorder(road,-count),y=count)) +
  geom_bar(stat ='identity') +
  ggtitle('Plot 1: Popularity of Street Name Identifiers (Descending)') +
  xlab('Street Name Identifiers') +
  ylab('Popularity (Count)')
```

# Part 5: Make at least two posts to groups discussion

Please reference to the group discussion page on canvas.
